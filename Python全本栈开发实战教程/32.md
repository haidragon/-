 # 用于方便查看回顾
# http://securitytech.cc/ 的免费文本教程

# [官网](securitytech.cc) 会长期更新工具、产品开发、产品开发教程、商业产品开发。视频教程。

# [本人介绍](http://securitytech.cc/about)

![公众号](https://github.com/haidragon/haidragon/blob/main/gzh.png)


 
## FastAPI 生态组件总览：构建全异步高性能应用

FastAPI 的核心在于其异步能力和对标准 Python 类型提示的深度利用。为了充分发挥这些优势，它与其他一流的异步兼容库紧密协作，形成了一个高效的技术栈，能够处理从数据存储到消息队列的各种复杂需求。

### 一、异步数据库 ORM 与 ODM

在异步 Web 框架中，使用同步的 ORM (Object-Relational Mapper) 或数据库驱动会阻塞事件循环，从而损害性能。因此，选择异步兼容的数据库工具至关重要。

#### 1. SQLAlchemy 2.0+ (异步 ORM)

* **核心功能：** SQLAlchemy 是 Python 中最强大和广泛使用的 SQL ORM 工具。从 1.4 版本开始，它引入了对**异步 I/O** 的支持，并在 2.0 版本中将其作为核心特性。
* **异步连接：** 通过 `create_async_engine` 和 `AsyncSession`，SQLAlchemy 可以在不阻塞事件循环的情况下执行数据库操作。
* **应用场景：** 适用于需要高度控制 SQL 查询、复杂关系映射或与传统数据库紧密集成的大型、复杂项目。
* **集成方式：** 通常结合 FastAPI 的**依赖注入系统**来管理异步数据库会话（`AsyncSession`），确保每个请求都有独立的数据库连接。

#### 2. Tortoise-ORM (异步 ORM)

* **核心功能：** 一个专为 `asyncio` 设计的 ORM，提供了类似于 Django ORM 的简洁 API。
* **易用性：** 相较于 SQLAlchemy，Tortoise-ORM 在某些方面可能学习曲线更平缓，尤其适合熟悉 Django ORM 的开发者。
* **应用场景：** 快速开发、中小型项目或对 ORM 抽象层有高要求的异步应用。
* **集成方式：** 直接在 FastAPI 应用启动时进行初始化，并提供依赖注入来获取模型或数据库连接。

#### 3. SQLModel (基于 Pydantic 和 SQLAlchemy 的现代 ORM/ODM)

* **核心功能：** 由 FastAPI 作者开发，结合了 Pydantic 的数据验证能力和 SQLAlchemy 的 ORM 功能。
* **类型安全：** 你可以用一个 Pydantic 模型来同时定义数据库表结构和 API 请求/响应模型，实现极致的类型安全和代码复用。
* **应用场景：** 对类型安全、开发效率和代码复用有高要求的项目，尤其适合与 FastAPI 紧密配合使用。

#### 4. Beanie (异步 MongoDB ODM)

* **核心功能：** 一个专为 MongoDB 和 `asyncio` 设计的异步 ODM (Object-Document Mapper)，基于 Pydantic。
* **易用性：** 提供类 Django ORM 的操作接口，简化 MongoDB 的操作。
* **应用场景：** 需要使用 MongoDB 作为数据库的异步应用。

### 二、数据库迁移工具

#### 1. Alembic

* **核心功能：** SQLAlchemy 的官方数据库迁移工具，用于管理数据库 Schema 的演变。
* **版本控制：** 允许你使用 Python 脚本来定义数据库的变更（如添加列、修改表），并对这些变更进行版本控制，确保数据库 Schema 与代码模型同步。
* **应用场景：** 任何使用 SQLAlchemy 作为 ORM 的 FastAPI 项目，尤其是在生产环境中，都需要使用 Alembic 进行数据库版本管理。

### 三、异步任务队列

对于耗时操作（如发送邮件、图片处理、复杂计算），将其从 Web 请求/响应循环中分离出来异步执行，是构建高性能、高响应性应用的关键。

#### 1. Celery

* **核心功能：** Python 生态中最流行、功能最强大的分布式任务队列系统。
* **异步执行：** 允许你将任务添加到队列中，由独立的 Celery worker 进程异步执行，不阻塞 FastAPI 的主线程。
* **定时任务：** 配合 `Celery Beat` 可以执行周期性任务。
* **应用场景：** 几乎所有需要处理后台任务、耗时操作或定时任务的 FastAPI 项目。

#### 2. Redis Queue (RQ)

* **核心功能：** 一个简单且轻量级的 Python 任务队列，基于 Redis。
* **易用性：** 配置和使用比 Celery 更简单，适合对任务队列需求不太复杂的项目。
* **应用场景：** 中小型项目，对 Redis 有依赖且对任务队列功能要求不高的情况。

#### 3. Dramatiq

* **核心功能：** 另一个现代的分布式任务队列，专注于简单性和可靠性。
* **应用场景：** 寻求 Celery 替代方案，看重简洁性和高性能的异步任务处理。

### 四、异步 Redis 客户端

Redis 经常被用作缓存、消息代理（pub/sub）、任务队列的后端等。在异步应用中，你需要一个异步兼容的 Redis 客户端。

#### 1. Asyncio-Redis / aioredis

* **核心功能：** 为 Python 的 `asyncio` 框架提供异步 Redis 客户端。
* **非阻塞：** 确保在与 Redis 交互时不会阻塞事件循环。
* **应用场景：** 缓存管理、实时通知系统、分布式锁、会话存储等。

### 五、HTTP 客户端

在你的 FastAPI 应用中，经常需要向其他外部 API 发送 HTTP 请求。

#### 1. httpx

* **核心功能：** Python 现代的 HTTP 客户端，原生支持 `async/await`。
* **易用性：** 提供与 `requests` 库相似的 API，但支持异步操作。
* **应用场景：** 向第三方服务发送 API 请求、微服务间通信等。

### 六、WebSockets

FastAPI 基于 Starlette，天然支持 WebSocket。

#### 1. WebSocket (内置)

* **核心功能：** FastAPI 内置了对 WebSocket 的支持，允许你构建实时双向通信的应用。
* **应用场景：** 聊天应用、实时仪表盘、游戏、通知系统等。

### 七、测试工具

#### 1. Pytest

* **核心功能：** Python 最流行和强大的测试框架。
* **插件生态：** 拥有丰富的插件生态系统，例如 `pytest-asyncio` 用于测试异步代码。
* **集成测试：** 结合 FastAPI 的 `TestClient`，可以轻松编写集成测试，模拟 HTTP 请求到你的 FastAPI 应用。

### 八、其他常用组件

* **FastAPI Security (内置)：** 提供 OAuth2、JWT 和 HTTP Basic 等多种认证机制的工具。
* **`python-multipart`：** 用于处理 HTML 表单数据和文件上传。
* **`passlib`：** 用于安全地进行密码哈希。
* **Docker：** 用于容器化 FastAPI 应用，便于部署和管理。
* **Uvicorn + Gunicorn：** 生产环境部署时，Gunicorn 作为进程管理器，Uvicorn 作为其 worker，提供更强大的健壮性和可伸缩性。

### 总结

FastAPI 的强大之处并非在于其“自带电池”的广度，而在于它能够**优雅而高效地整合 Python 异步生态中的顶尖工具**。从异步 ORM 到任务队列，从数据库迁移到实时通信，这个生态系统为构建高性能、可扩展的现代 API 服务提供了全面的解决方案。理解这些组件及其在 FastAPI 架构中的作用，将使你能够充分发挥框架的潜力，满足复杂的业务需求。

 


 ---

# 案例

## 一、Django 核心框架与内置组件案例
 
#### 1. **URL Dispatcher (URLconf)**
负责将 HTTP 请求的 URL 模式映射到相应的**视图函数**或**类视图**。

**代码示例:**
```python
# myproject/urls.py (项目主路由)
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('products/', include('products.urls')), # 包含 'products' 应用的路由
    path('users/', include('users.urls')),       # 包含 'users' 应用的路由
]

# products/urls.py (products 应用路由)
from django.urls import path
from . import views

urlpatterns = [
    path('', views.product_list, name='product_list'),
    path('<int:product_id>/', views.product_detail, name='product_detail'),
]
```

#### 2. **ORM (Object-Relational Mapper)**
允许你通过 Python 对象和方法来操作数据库，无需编写原始 SQL。

**代码示例:**
```python
# products/models.py
from django.db import models

class Category(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True, null=True)

    def __str__(self):
        return self.name

class Product(models.Model):
    name = models.CharField(max_length=200)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    stock = models.IntegerField(default=0)
    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, related_name='products')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name

    def is_in_stock(self):
        return self.stock > 0

    # 自定义管理器，例如只查询有库存的商品
    class ProductManager(models.Manager):
        def in_stock(self):
            return self.filter(stock__gt=0)

    objects = models.Manager() # 默认管理器
    in_stock_products = ProductManager() # 自定义管理器

# 使用 ORM
# from products.models import Product, Category
# # 创建
# category = Category.objects.create(name='Electronics')
# product = Product.objects.create(name='Laptop', description='Powerful laptop', price=1200.00, stock=50, category=category)
# # 查询
# all_products = Product.objects.all()
# laptops = Product.objects.filter(name__icontains='laptop', price__gt=1000)
# in_stock_items = Product.in_stock_products.filter(category__name='Electronics').order_by('-price')
# # 更新
# product.price = 1150.00
# product.save()
# Product.objects.filter(category=category).update(stock=models.F('stock') + 10) # 批量更新
# # 删除
# product.delete()
```

#### 3. **Admin 后台 (Django Admin)**
一个基于模型自动生成且高度可定制的管理界面。

**代码示例:**
```python
# products/admin.py
from django.contrib import admin
from .models import Category, Product

@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):
    list_display = ('name', 'description')
    search_fields = ('name',)

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ('name', 'price', 'stock', 'category', 'is_in_stock', 'created_at')
    list_filter = ('category', 'is_in_stock', 'created_at')
    search_fields = ('name', 'description')
    raw_id_fields = ('category',) # 对于外键字段，使用原始ID输入框，避免加载所有关联对象
    actions = ['make_out_of_stock'] # 注册自定义动作

    def make_out_of_stock(self, request, queryset):
        updated_count = queryset.update(stock=0)
        self.message_user(request, f"{updated_count} selected products marked as out of stock.")
    make_out_of_stock.short_description = "将选定的商品标记为缺货"
```
要启用 Admin，确保 `django.contrib.admin` 在 `INSTALLED_APPS` 中。

#### 4. **认证系统 (Authentication and Authorization System)**
一套安全且可扩展的用户管理和权限控制系统。

**代码示例:**
```python
# views.py (用户登录示例)
from django.shortcuts import render, redirect
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.decorators import login_required, permission_required

def user_login(request):
    if request.method == 'POST':
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            username = form.cleaned_data.get('username')
            password = form.cleaned_data.get('password')
            user = authenticate(username=username, password=password)
            if user is not None:
                login(request, user)
                return redirect('product_list') # 登录成功跳转
    else:
        form = AuthenticationForm()
    return render(request, 'users/login.html', {'form': form})

@login_required # 要求用户登录才能访问
def user_profile(request):
    return render(request, 'users/profile.html', {'user': request.user})

@permission_required('products.add_product') # 要求用户有添加商品的权限
def add_product_view(request):
    # ... 只有有权限的用户才能访问此视图
    pass

# urls.py
# path('login/', views.user_login, name='login'),
# path('profile/', views.user_profile, name='profile'),
# path('add_product/', views.add_product_view, name='add_product'),
```

#### 5. **表单系统 (Forms)**
用于处理 HTML 表单的强大工具。

**代码示例:**
```python
# products/forms.py
from django import forms
from .models import Product

class ProductForm(forms.ModelForm): # 基于模型的表单
    class Meta:
        model = Product
        fields = ['name', 'description', 'price', 'stock', 'category']
        widgets = {
            'description': forms.Textarea(attrs={'rows': 4}),
        }
        labels = {
            'name': '商品名称',
            'price': '价格 (元)',
        }
        help_texts = {
            'stock': '当前库存数量',
        }

    # 自定义字段验证
    def clean_price(self):
        price = self.cleaned_data['price']
        if price <= 0:
            raise forms.ValidationError("价格必须大于零。")
        return price

# products/views.py
from django.shortcuts import render, redirect, get_object_or_404
from .forms import ProductForm

def create_product(request):
    if request.method == 'POST':
        form = ProductForm(request.POST)
        if form.is_valid():
            form.save() # 直接保存到数据库
            return redirect('product_list')
    else:
        form = ProductForm()
    return render(request, 'products/product_form.html', {'form': form})

def update_product(request, product_id):
    product = get_object_or_404(Product, pk=product_id)
    if request.method == 'POST':
        form = ProductForm(request.POST, instance=product) # 传入 instance 进行更新
        if form.is_valid():
            form.save()
            return redirect('product_detail', product_id=product.id)
    else:
        form = ProductForm(instance=product)
    return render(request, 'products/product_form.html', {'form': form, 'product': product})

# templates/products/product_form.html
<form method="post">
    {% csrf_token %} {# CSRF 保护 #}
    {{ form.as_p }} {# 渲染表单字段为段落 #}
    <button type="submit">保存</button>
</form>
```

#### 6. **模板系统 (Template System)**
用于渲染动态内容的表现层。

**代码示例:**
```html
{# products/templates/products/product_list.html #}
{% extends 'base.html' %} {# 模板继承 #}

{% block title %}商品列表{% endblock %}

{% block content %}
    <h1>所有商品</h1>
    <ul>
        {% for product in products %} {# 模板循环 #}
            <li>
                <a href="{% url 'product_detail' product.id %}">{{ product.name }}</a> - {{ product.price|floatformat:2 }} 元
                {% if not product.is_in_stock %} {# 模板条件判断 #}
                    <span style="color: red;">(缺货)</span>
                {% endif %}
            </li>
        {% empty %} {# 循环为空时执行 #}
            <li>目前没有商品。</li>
        {% endfor %}
    </ul>

    <a href="{% url 'create_product' %}">添加新商品</a>
{% endblock %}
```

#### 7. **中间件 (Middleware)**
实现了 **AOP (Aspect-Oriented Programming)** 理念，允许你在请求/响应生命周期的不同阶段插入自定义逻辑。

**代码示例:**
```python
# myproject/settings.py
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'myapp.middleware.RequestLoggingMiddleware', # 你的自定义中间件
]

# myapp/middleware.py
import time
from django.utils.deprecation import MiddlewareMixin

class RequestLoggingMiddleware(MiddlewareMixin):
    def process_request(self, request):
        # 请求进入视图之前执行
        request.start_time = time.time()
        print(f"Request started for: {request.path}")

    def process_response(self, request, response):
        # 视图执行后，响应返回客户端之前执行
        if hasattr(request, 'start_time'):
            duration = time.time() - request.start_time
            print(f"Request for {request.path} completed in {duration:.4f} seconds with status {response.status_code}")
        return response

    def process_exception(self, request, exception):
        # 如果视图或之前的中间件抛出异常时执行
        print(f"Exception caught for {request.path}: {exception}")
        # 可以返回一个 HttpResponse 来替代默认的错误页面
        # from django.http import HttpResponseServerError
        # return HttpResponseServerError("Custom error message")
```

#### 8. **Signals (信号机制)**
实现了**发布-订阅模式**，用于解耦应用组件间的通信。

**代码示例:**
```python
# products/signals.py
from django.db.models.signals import post_save, pre_delete
from django.dispatch import receiver
from .models import Product

@receiver(post_save, sender=Product)
def product_saved_handler(sender, instance, created, **kwargs):
    if created:
        print(f"新产品 '{instance.name}' 已创建。")
    else:
        print(f"产品 '{instance.name}' 已更新。")
    # 可以在这里触发邮件通知、日志记录等

@receiver(pre_delete, sender=Product)
def product_deleted_handler(sender, instance, **kwargs):
    print(f"产品 '{instance.name}' 即将被删除。")
    # 可以在这里做一些清理工作，比如删除关联的文件

# products/apps.py
from django.apps import AppConfig

class ProductsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'products'

    def ready(self):
        import products.signals # 导入信号处理器，使其生效
```

---

### 二、Django REST Framework (DRF)：构建 RESTful API 的利器

**Django REST Framework (DRF)** 是 Django 生态中一个极其重要且广受欢迎的第三方库，它极大地简化了构建 RESTful API 的过程。

**安装：** `pip install djangorestframework`
**添加到 `settings.py`：**
```python
# myproject/settings.py
INSTALLED_APPS = [
    # ...
    'rest_framework',
    # ...
]
```

#### 1. **序列化器 (Serializers)**
将 Django 模型实例或其他数据类型**序列化**成 JSON/XML 等可传输格式，以及将传入的 JSON/XML 数据**反序列化**为 Python 数据结构。

**代码示例:**
```python
# products/serializers.py
from rest_framework import serializers
from .models import Product, Category

class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = Category
        fields = ['id', 'name']

class ProductSerializer(serializers.ModelSerializer):
    # 嵌套序列化器显示关联的分类信息
    category = CategorySerializer(read_only=True)
    # 用于写入时通过ID选择分类
    category_id = serializers.PrimaryKeyRelatedField(
        queryset=Category.objects.all(), source='category', write_only=True
    )

    class Meta:
        model = Product
        fields = ['id', 'name', 'description', 'price', 'stock', 'category', 'category_id', 'created_at', 'updated_at']
        read_only_fields = ['created_at', 'updated_at'] # 只读字段

    # 自定义验证方法
    def validate_stock(self, value):
        if value < 0:
            raise serializers.ValidationError("库存不能为负数。")
        return value

# 使用序列化器
# from products.models import Product
# from products.serializers import ProductSerializer
# product = Product.objects.get(id=1)
# serializer = ProductSerializer(product)
# print(serializer.data) # 序列化为字典
# # 反序列化
# data = {'name': 'New Gadget', 'description': 'Cool stuff', 'price': 99.99, 'stock': 100, 'category_id': 1}
# serializer = ProductSerializer(data=data)
# if serializer.is_valid(raise_exception=True): # 验证数据
#     product_instance = serializer.save() # 保存到数据库
```

#### 2. **视图集 (ViewSets) / 视图 (Views)**
DRF 提供了 `APIView` 基类和更高级的 `ViewSet` 抽象，用于处理 API 请求。

**代码示例:**
```python
# products/views.py (使用 ViewSet)
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action # 用于自定义动作
from .models import Product, Category
from .serializers import ProductSerializer, CategorySerializer
from .permissions import IsAdminOrReadOnly # 导入自定义权限

class CategoryViewSet(viewsets.ModelViewSet):
    queryset = Category.objects.all()
    serializer_class = CategorySerializer
    permission_classes = [IsAdminOrReadOnly] # 应用权限

class ProductViewSet(viewsets.ModelViewSet):
    queryset = Product.objects.all()
    serializer_class = ProductSerializer
    permission_classes = [IsAdminOrReadOnly]
    # filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter] # 启用过滤、搜索、排序
    # filterset_fields = ['category', 'stock']
    # search_fields = ['name', 'description']
    # ordering_fields = ['price', 'created_at']
    # pagination_class = PageNumberPagination # 启用分页

    @action(detail=True, methods=['post']) # 自定义动作 (POST /products/{id}/buy/)
    def buy(self, request, pk=None):
        product = self.get_object()
        quantity = request.data.get('quantity', 1)
        if product.stock >= quantity:
            product.stock -= quantity
            product.save()
            return Response({'status': 'item bought'}, status=status.HTTP_200_OK)
        else:
            return Response({'error': 'Not enough stock'}, status=status.HTTP_400_BAD_REQUEST)

# products/views.py (使用 APIView，更灵活，但需手动实现CRUD)
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

class ProductListAPIView(APIView):
    def get(self, request, format=None):
        products = Product.objects.all()
        serializer = ProductSerializer(products, many=True)
        return Response(serializer.data)

    def post(self, request, format=None):
        serializer = ProductSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```

#### 3. **路由 (Routers)**
DRF 的路由器与视图集配合，可以自动生成符合 RESTful 惯例的 URL 模式。

**代码示例:**
```python
# myproject/urls.py (项目主路由)
from django.contrib import admin
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from products import views as product_views # 导入 ViewSet

router = DefaultRouter()
router.register(r'products', product_views.ProductViewSet, basename='product')
router.register(r'categories', product_views.CategoryViewSet, basename='category')

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include(router.urls)), # 注册 DRF 路由器生成的 URL
    # path('api-auth/', include('rest_framework.urls', namespace='rest_framework')), # DRF 提供的登录/注销视图 (可选)
]
```
这会自动为 `ProductViewSet` 和 `CategoryViewSet` 生成 `/api/products/`, `/api/products/{id}/`, `/api/categories/` 等 URL。

#### 4. **认证 (Authentication) 与 权限 (Permissions)**
DRF 提供了多种认证方式和细粒度的权限控制。

**代码示例:**
```python
# myproject/settings.py
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication', # 基于Token认证
        'rest_framework.authentication.SessionAuthentication', # 基于Session认证 (用于浏览器)
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticatedOrReadOnly', # 默认只读，POST/PUT/DELETE需要认证
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10, # 每页10条
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend', # 过滤器
        'rest_framework.filters.SearchFilter', # 搜索
        'rest_framework.filters.OrderingFilter', # 排序
    ]
}

# users/models.py (如果使用 TokenAuthentication，需要生成 Token)
from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from rest_framework.authtoken.models import Token # 需要安装 djangorestframework

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_auth_token(sender, instance=None, created=False, **kwargs):
    if created:
        Token.objects.create(user=instance)

# products/permissions.py (自定义权限示例)
from rest_framework import permissions

class IsAdminOrReadOnly(permissions.BasePermission):
    """
    自定义权限，只允许管理员进行写操作，其他用户只读。
    """
    def has_permission(self, request, view):
        # 允许GET, HEAD, OPTIONS 请求 (只读权限)
        if request.method in permissions.SAFE_METHODS:
            return True
        # 写权限只允许管理员
        return request.user and request.user.is_staff

    def has_object_permission(self, request, view, obj):
        # 对象级别的权限，这里是所有认证用户只读，管理员可修改
        if request.method in permissions.SAFE_METHODS:
            return True
        return request.user and request.user.is_staff
```

#### 5. **过滤 (Filtering) 与 分页 (Pagination)**
允许 API 客户端通过 URL 参数来过滤数据集，并为大型结果集提供分页功能。

**代码示例:** (已在上述 `ProductViewSet` 中注释掉，需安装 `django-filter`)
```python
# pip install django-filter
# settings.py 中添加 'django_filters' 到 INSTALLED_APPS
# 在 ViewSet 中取消 filter_backends, filterset_fields, search_fields, ordering_fields, pagination_class 的注释。

# 示例请求 URL:
# /api/products/?category=1&stock__gt=0&search=laptop&ordering=-price&page=2
```

---

### 三、其他重要的生态组件

除了 DRF，还有许多第三方库在 Django 生态中扮演着关键角色。

#### 1. **Celery：异步任务队列**
用于处理耗时、阻塞或周期性的任务。

**代码示例:**
```python
# myproject/celery.py
import os
from celery import Celery

# 设置 Django 的 settings 模块
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

app = Celery('myproject')

# 从 Django 的 settings.py 中加载 Celery 配置
app.config_from_object('django.conf:settings', namespace='CELERY')

# 自动发现所有已注册的 Django 应用中的 tasks.py 文件
app.autodiscover_tasks()

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')

# products/tasks.py
from celery import shared_task
import time

@shared_task
def send_product_notification(product_id, email):
    # 模拟耗时操作，例如发送邮件
    time.sleep(5)
    print(f"Sending notification for product {product_id} to {email}")
    # from django.core.mail import send_mail
    # send_mail('Product Update', f'Product {product_id} was updated.', 'from@example.com', [email])
    return f"Notification sent for product {product_id}"

# products/views.py (调用 Celery 任务)
from django.http import JsonResponse
from .tasks import send_product_notification

def trigger_notification(request, product_id):
    if request.method == 'POST':
        email = request.POST.get('email', 'admin@example.com')
        # 异步调用任务，不会阻塞当前请求
        send_product_notification.delay(product_id, email)
        return JsonResponse({"message": f"Notification task for product {product_id} queued."})
    return JsonResponse({"error": "Please use POST method."}, status=400)

# 运行 Celery Worker: celery -A myproject worker -l info
# 运行 Celery Beat (定时任务调度): celery -A myproject beat -l info
```

#### 2. **Django-Channels：WebSocket 和异步协议**
将 Django 从传统的 HTTP 请求-响应模型扩展到支持 WebSocket 等异步通信。

**安装：** `pip install channels daphne`
**添加到 `settings.py`：**
```python
# myproject/settings.py
INSTALLED_APPS = [
    # ...
    'channels',
    # ...
]

# ASGI 配置
ASGI_APPLICATION = 'myproject.asgi.application'

# CHANNEL_LAYERS = { # 可选，用于多实例或分布式消息广播
#     'default': {
#         'BACKEND': 'channels_redis.pubsub.RedisPubSubChannelLayer',
#         'CONFIG': {
#             'hosts': [('localhost', 6379)],
#         },
#     },
# }
```

**代码示例:**
```python
# myproject/asgi.py (ASGI 应用入口)
import os
from channels.auth import AuthMiddlewareStack
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application
import myapp.routing # 导入你的 WebSocket 路由

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

application = ProtocolTypeRouter({
    "http": get_asgi_application(), # HTTP 请求由 Django 处理
    "websocket": AuthMiddlewareStack( # WebSocket 请求
        URLRouter(
            myapp.routing.websocket_urlpatterns # 你的 WebSocket 路由
        )
    ),
})

# myapp/consumers.py (WebSocket 消费者)
import json
from channels.generic.websocket import AsyncWebsocketConsumer

class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.room_name = self.scope['url_route']['kwargs']['room_name']
        self.room_group_name = f'chat_{self.room_name}'

        # 加入房间组
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        await self.accept() # 接受连接

    async def disconnect(self, close_code):
        # 离开房间组
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )

    # 从 WebSocket 接收到消息时
    async def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json['message']

        # 将消息发送到房间组
        await self.channel_layer.group_send(
            self.room_group_name,
            {
                'type': 'chat_message', # 消息类型
                'message': message
            }
        )

    # 从房间组接收到消息时 (由 send 方法调用)
    async def chat_message(self, event):
        message = event['message']

        # 将消息发送回 WebSocket
        await self.send(text_data=json.dumps({
            'message': message
        }))

# myapp/routing.py (WebSocket 路由)
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/chat/(?P<room_name>\w+)/$', consumers.ChatConsumer.as_asgi()),
]

# 前端 JS 示例 (假设在 HTML 中):
// const chatSocket = new WebSocket(
//     'ws://' + window.location.host + '/ws/chat/my_room/'
// );
// chatSocket.onmessage = function(e) {
//     const data = JSON.parse(e.data);
//     console.log(data.message);
// };
// chatSocket.onclose = function(e) { console.error('Chat socket closed unexpectedly'); };
// chatSocket.send(JSON.stringify({'message': 'Hello from client'}));
```

#### 3. **Django-Debug-Toolbar：开发调试利器**
在开发环境中提供一个高度交互式的调试面板。

**安装：** `pip install django-debug-toolbar`
**添加到 `settings.py`：**
```python
# myproject/settings.py
INSTALLED_APPS = [
    # ...
    'debug_toolbar',
    # ...
]

MIDDLEWARE = [
    # ...
    'debug_toolbar.middleware.DebugToolbarMiddleware', # 尽可能放置在列表靠前
    # ...
]

INTERNAL_IPS = [ # 允许哪些IP访问 Debug Toolbar
    '127.0.0.1',
    'localhost',
]

# myproject/urls.py
import debug_toolbar
from django.urls import path, include

urlpatterns = [
    # ...
    path('__debug__/', include(debug_toolbar.urls)), # 调试工具栏 URL
    # ...
]
```
运行 `python manage.py runserver` 后，访问页面即可在右侧看到调试工具栏。

---

### 四、Django 管理命令与 CLI 扩展

允许你通过命令行与项目交互、执行各种任务。

#### 1. 内置命令的使用

**代码示例:**
```bash
python manage.py runserver 8001            # 启动开发服务器在 8001 端口
python manage.py makemigrations myapp      # 为 myapp 应用生成迁移文件
python manage.py migrate                   # 应用所有未应用的迁移
python manage.py createsuperuser           # 创建超级用户
python manage.py shell                     # 进入 Django shell
python manage.py test myapp                # 运行 myapp 的所有测试
```

#### 2. 编写和注册自定义管理命令

**代码示例:**
```python
# myapp/management/commands/cleanup_old_data.py
from django.core.management.base import BaseCommand, CommandError
from django.utils import timezone
from datetime import timedelta
# from myapp.models import OldLogEntry # 假设你有这个模型

class Command(BaseCommand):
    help = '清理指定天数之前的旧数据。'

    def add_arguments(self, parser):
        parser.add_argument(
            '--days',
            type=int,
            default=30,
            help='保留多少天之内的数据，之外的删除 (默认为30天)。'
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='只显示将要删除的数据，不实际执行删除操作。'
        )

    def handle(self, *args, **options):
        days_to_keep = options['days']
        dry_run = options['dry_run']

        threshold_date = timezone.now() - timedelta(days=days_to_keep)
        # 假设你有一个名为 OldLogEntry 的模型，并且有一个 created_at 字段
        # old_records = OldLogEntry.objects.filter(created_at__lt=threshold_date)
        
        # 模拟数据查询
        old_records_count = 100 # 假设查询到100条记录

        self.stdout.write(self.style.NOTICE(f"开始清理 {days_to_keep} 天前的旧数据..."))
        self.stdout.write(f"数据阈值日期：{threshold_date.strftime('%Y-%m-%d %H:%M:%S')}")

        if old_records_count == 0:
            self.stdout.write(self.style.SUCCESS("没有找到需要清理的旧数据。"))
            return

        self.stdout.write(f"找到 {old_records_count} 条旧数据。")

        if dry_run:
            self.stdout.write(self.style.WARNING("这是空运行模式，不会实际删除数据。"))
            # for record in old_records:
            #     self.stdout.write(f"将删除（空运行）：ID={record.id}, Created={record.created_at}")
        else:
            confirmation = input("确定要删除这些数据吗？(yes/no): ")
            if confirmation.lower() != 'yes':
                self.stdout.write(self.style.WARNING("操作已取消。"))
                return

            # deleted_count, _ = old_records.delete() # 实际删除
            deleted_count = old_records_count # 模拟删除

            self.stdout.write(self.style.SUCCESS(f"成功清理了 {deleted_count} 条旧数据。"))

        self.stdout.write(self.style.SUCCESS("清理命令执行完毕。"))

# 运行命令:
# python manage.py cleanup_old_data --days 60 --dry-run
# python manage.py cleanup_old_data
```

---

### 五、配置隔离与环境变量支持

使用 `django-environ` 或 `python-decouple` 实现灵活的配置管理，多环境部署策略。

**安装：** `pip install django-environ`
**`.env` 文件 (添加到 `.gitignore`)**
```ini
# .env
DEBUG=True
SECRET_KEY=your-insecure-dev-key
DATABASE_URL=sqlite:///db.sqlite3
ALLOWED_HOSTS=127.0.0.1,localhost
EMAIL_HOST=smtp.mailtrap.io
EMAIL_PORT=2525
EMAIL_HOST_USER=your_mailtrap_user
EMAIL_HOST_PASSWORD=your_mailtrap_password
```

**代码示例:**
```python
# myproject/settings.py
import environ
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

env = environ.Env(
    # 定义默认值和类型，如果环境变量不存在或无法转换
    DEBUG=(bool, False),
    ALLOWED_HOSTS=(list, []),
)

# 读取 .env 文件。在生产环境通常不使用 .env 文件，而是直接设置系统环境变量。
# 确保在生产环境中移除或不调用此行
environ.Env.read_env(str(BASE_DIR / '.env'))

# 基本设置
SECRET_KEY = env('SECRET_KEY')
DEBUG = env('DEBUG')
ALLOWED_HOSTS = env.list('ALLOWED_HOSTS')

# 数据库配置
DATABASES = {
    'default': env.db(), # 从 DATABASE_URL 解析
}

# 邮件配置
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = env('EMAIL_HOST', default='localhost') # 可以提供默认值
EMAIL_PORT = env.int('EMAIL_PORT', default=25)
EMAIL_HOST_USER = env('EMAIL_HOST_USER', default='')
EMAIL_HOST_PASSWORD = env('EMAIL_HOST_PASSWORD', default='')
EMAIL_USE_TLS = env.bool('EMAIL_USE_TLS', default=False)
EMAIL_USE_SSL = env.bool('EMAIL_USE_SSL', default=False)

# 生产环境示例
# 在生产服务器上，你会设置系统环境变量：
# export DEBUG=False
# export SECRET_KEY=your-super-long-production-key-from-vault
# export DATABASE_URL="postgresql://user:password@host:port/dbname"
# export ALLOWED_HOSTS="yourdomain.com,api.yourdomain.com"
```

---

### 六、Django 应用模块结构与分层架构实践

合理组织 Project 与 App，设计可复用 App，并在 Django 中初步应用 DDD (领域驱动设计)。

#### 1. Project 与 App 的合理组织

**项目结构示例:**
```
my_django_project/
├── manage.py
├── my_django_project/           # Project 配置目录
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   ├── wsgi.py
│   └── asgi.py
├── .env                         # 环境变量 (git ignored)
├── requirements.txt
├── users/                       # App: 用户管理
│   ├── migrations/
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── models.py
│   ├── views.py
│   ├── urls.py
│   ├── forms.py
│   └── tests.py
├── products/                    # App: 商品管理
│   ├── migrations/
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── models.py
│   ├── serializers.py           # DRF 序列化器
│   ├── views.py
│   ├── urls.py
│   ├── forms.py
│   ├── tests.py
│   └── templates/products/
├── orders/                      # App: 订单管理
│   ├── ...
├── common/                      # 可复用 App: 通用工具、基类、抽象等
│   ├── __init__.py
│   ├── models.py                # 例如 AbstractBaseModel
│   └── utils.py
└── templates/                   # 项目级别通用模板
    └── base.html
```

#### 2. DDD (领域驱动设计) 在 Django 中的初步应用

**代码示例:**
**富领域模型 (将业务逻辑封装到模型方法中)**
```python
# products/models.py
from django.db import models

class Product(models.Model):
    name = models.CharField(max_length=200)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    stock = models.IntegerField(default=0)
    is_active = models.BooleanField(default=True)

    def decrease_stock(self, quantity: int) -> bool:
        """
        减少商品库存。
        返回 True 表示成功，False 表示库存不足。
        """
        if quantity <= 0:
            raise ValueError("减少数量必须大于零。")
        if self.stock >= quantity:
            self.stock -= quantity
            self.save()
            print(f"库存减少：{self.name}, 剩余库存：{self.stock}")
            return True
        else:
            print(f"库存不足：{self.name}, 仅剩 {self.stock}")
            return False

    def activate(self):
        """激活产品。"""
        if not self.is_active:
            self.is_active = True
            self.save()
            print(f"产品 '{self.name}' 已激活。")

    def deactivate(self):
        """停用产品。"""
        if self.is_active:
            self.is_active = False
            self.save()
            print(f"产品 '{self.name}' 已停用。")
```

**服务层 (Service Layer) / 领域服务 (处理跨模型或复杂业务逻辑)**
```python
# orders/services.py
from django.db import transaction
from products.models import Product # 导入产品模型
from .models import Order, OrderItem # 导入订单模型

class OrderService:
    @staticmethod
    @transaction.atomic # 确保整个操作的原子性
    def create_order_with_items(user, items_data: list) -> Order:
        """
        创建一个新订单，并处理其中包含的商品及库存扣减。
        items_data 示例: [{"product_id": 1, "quantity": 2}, {"product_id": 2, "quantity": 1}]
        """
        if not items_data:
            raise ValueError("订单中必须包含商品。")

        order = Order.objects.create(user=user, status=Order.STATUS_PENDING, total_amount=0)
        total_amount = 0

        for item_data in items_data:
            product_id = item_data.get('product_id')
            quantity = item_data.get('quantity')

            try:
                product = Product.objects.select_for_update().get(id=product_id, is_active=True) # 加悲观锁并确保产品活跃
            except Product.DoesNotExist:
                raise ValueError(f"产品 ID {product_id} 不存在或已停用。")

            if not product.decrease_stock(quantity): # 调用产品模型的领域行为
                transaction.set_rollback(True) # 手动回滚事务
                raise ValueError(f"产品 '{product.name}' 库存不足。")

            item_price = product.price * quantity
            OrderItem.objects.create(
                order=order,
                product=product,
                quantity=quantity,
                price_at_purchase=product.price # 记录购买时的价格
            )
            total_amount += item_price

        order.total_amount = total_amount
        order.status = Order.STATUS_CREATED # 订单创建成功
        order.save()
        return order

# orders/views.py (使用服务层)
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from .services import OrderService
from rest_framework.permissions import IsAuthenticated

class PlaceOrderAPIView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        user = request.user
        items_data = request.data.get('items', []) # 从请求体获取商品数据

        try:
            order = OrderService.create_order_with_items(user, items_data)
            return Response({'message': 'Order placed successfully', 'order_id': order.id}, status=status.HTTP_201_CREATED)
        except ValueError as e:
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            # 捕获其他未知错误
            return Response({'error': 'An unexpected error occurred.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```

---

### 七、依赖注入模式与服务注册实现

在 Django 中实现松耦合的依赖管理。

**代码示例:**
**简单服务容器模式:**
```python
# myproject/core/services.py (你的服务定义)
class PaymentGateway:
    def process_payment(self, amount, card_info):
        print(f"Processing payment of {amount} using {card_info[:4]}****")
        # 实际支付API调用
        return True

class NotificationService:
    def __init__(self, email_sender):
        self.email_sender = email_sender

    def send_welcome_email(self, user_email):
        self.email_sender.send_email(user_email, "Welcome!", "Thanks for registering!")

class EmailSender: # 依赖接口
    def send_email(self, to, subject, body):
        raise NotImplementedError

class ConsoleEmailSender(EmailSender): # 开发环境实现
    def send_email(self, to, subject, body):
        print(f"[Console Email] To: {to}, Subject: {subject}, Body: {body}")

from django.core.mail import send_mail
class DjangoEmailSender(EmailSender): # 生产环境实现
    def send_email(self, to, subject, body):
        send_mail(subject, body, 'noreply@example.com', [to], fail_silently=False)
        print(f"[Django Mail] Email sent to {to}")

# myproject/core/container.py (简单服务容器)
from django.conf import settings
from myproject.core.services import (
    PaymentGateway, NotificationService,
    ConsoleEmailSender, DjangoEmailSender, EmailSender
)

class ServiceContainer:
    _instances = {}

    @classmethod
    def register(cls, name: str, instance):
        cls._instances[name] = instance

    @classmethod
    def get(cls, name: str):
        if name not in cls._instances:
            raise ValueError(f"Service '{name}' not registered.")
        return cls._instances[name]

    @classmethod
    def setup(cls):
        # 注册 EmailSender (根据 DEBUG 模式选择实现)
        if settings.DEBUG:
            email_sender: EmailSender = ConsoleEmailSender()
        else:
            email_sender: EmailSender = DjangoEmailSender()
        cls.register("email_sender", email_sender)

        # 注册 PaymentGateway
        cls.register("payment_gateway", PaymentGateway())

        # 注册 NotificationService 并注入 EmailSender 依赖
        cls.register("notification_service", NotificationService(email_sender=cls.get("email_sender")))

# myproject/apps.py (项目主 AppConfig，或任何应用 AppConfig)
from django.apps import AppConfig

class MyProjectAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'myproject.core' # 假设 core 目录是你的一个应用

    def ready(self):
        # 在 Django 应用启动时初始化并注册服务
        from . import container
        container.ServiceContainer.setup()
        print("ServiceContainer initialized and services registered.")

# users/views.py (使用注入的服务)
from django.http import JsonResponse
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny # 允许任何用户

# 从容器中获取服务
from myproject.core.container import ServiceContainer

class UserRegistrationView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        username = request.data.get('username')
        email = request.data.get('email')
        password = request.data.get('password')

        # 获取注入的服务
        notification_service = ServiceContainer.get("notification_service")
        payment_gateway = ServiceContainer.get("payment_gateway") # 即使这里用不到，也可以演示获取

        # 假设这里是用户创建逻辑
        # User.objects.create_user(username=username, email=email, password=password)

        # 发送欢迎邮件（通过注入的通知服务）
        notification_service.send_welcome_email(email)

        # 模拟支付（通过注入的支付网关）
        if payment_gateway.process_payment(10.00, "1234-****"):
            return JsonResponse({"message": "User registered and payment processed."})
        else:
            return JsonResponse({"message": "User registered, but payment failed."}, status=400)
```
 